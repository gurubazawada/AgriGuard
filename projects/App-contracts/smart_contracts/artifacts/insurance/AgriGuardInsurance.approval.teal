#pragma version 10
#pragma typetrack false

// smart_contracts.insurance.contract.AgriGuardInsurance.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 100 2 1000
    bytecblock 0x151f7c75 "next_policy_id" 0x0000000000000000 "policies" "admin" "oracle" 0x0000000000000001 0x0062
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/insurance/contract.py:35-36
    // # Global state
    // self.admin = Account()
    bytec 4 // "admin"
    global ZeroAddress
    app_global_put
    // smart_contracts/insurance/contract.py:37
    // self.oracle = Account()
    bytec 5 // "oracle"
    global ZeroAddress
    app_global_put
    // smart_contracts/insurance/contract.py:38
    // self.next_policy_id = UInt64(1)
    bytec_1 // "next_policy_id"
    intc_0 // 1
    app_global_put

main_after_if_else@2:
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txn NumAppArgs
    bz main_after_if_else@17
    pushbytess 0x894a716e 0x3368f556 0x671721d6 0x50f992ac 0xef909f38 0x5c1689a2 0xeb0de02b 0x3f78f6e3 0xabf6d51a 0xfa20020c 0xdce31bbe 0x1a0e2048 // method "create_application(address)void", method "set_oracle(address)void", method "buy_policy_with_payment(byte[],uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64", method "buy_policy(byte[],uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64", method "oracle_settle(uint64,uint64)uint64", method "dispute_settlement(uint64,string)uint64", method "get_policy(uint64)(address,string,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "get_policies_by_owner(address)(uint64,uint64)", method "get_policy_count()uint64", method "calculate_fee(uint64,uint64,uint64,uint64)uint64", method "delete_policy(uint64)uint64", method "get_globals()(address,address,uint64)"
    txna ApplicationArgs 0
    match main_create_application_route@5 main_set_oracle_route@6 main_buy_policy_with_payment_route@7 main_buy_policy_route@8 main_oracle_settle_route@9 main_dispute_settlement_route@10 main_get_policy_route@11 main_get_policies_by_owner_route@12 main_get_policy_count_route@13 main_calculate_fee_route@14 main_delete_policy_route@15 main_get_globals_route@16

main_after_if_else@17:
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    intc_1 // 0
    return

main_get_globals_route@16:
    // smart_contracts/insurance/contract.py:299
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_globals
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_delete_policy_route@15:
    // smart_contracts/insurance/contract.py:266
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/insurance/contract.py:266
    // @abimethod
    callsub delete_policy
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_calculate_fee_route@14:
    // smart_contracts/insurance/contract.py:232
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/insurance/contract.py:232
    // @abimethod(readonly=True)
    callsub calculate_fee
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_policy_count_route@13:
    // smart_contracts/insurance/contract.py:227
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_policy_count
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_policies_by_owner_route@12:
    // smart_contracts/insurance/contract.py:205
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/insurance/contract.py:205
    // @abimethod(readonly=True)
    callsub get_policies_by_owner
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_policy_route@11:
    // smart_contracts/insurance/contract.py:200
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/insurance/contract.py:200
    // @abimethod(readonly=True)
    callsub get_policy
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_dispute_settlement_route@10:
    // smart_contracts/insurance/contract.py:172
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/insurance/contract.py:172
    // @abimethod
    callsub dispute_settlement
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_oracle_settle_route@9:
    // smart_contracts/insurance/contract.py:140
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/insurance/contract.py:140
    // @abimethod
    callsub oracle_settle
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_buy_policy_route@8:
    // smart_contracts/insurance/contract.py:102
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    txna ApplicationArgs 8
    // smart_contracts/insurance/contract.py:102
    // @abimethod
    callsub buy_policy
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_buy_policy_with_payment_route@7:
    // smart_contracts/insurance/contract.py:54
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    txna ApplicationArgs 8
    // smart_contracts/insurance/contract.py:54
    // @abimethod
    callsub buy_policy_with_payment
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_set_oracle_route@6:
    // smart_contracts/insurance/contract.py:48
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/insurance/contract.py:48
    // @abimethod
    callsub set_oracle
    intc_0 // 1
    return

main_create_application_route@5:
    // smart_contracts/insurance/contract.py:43
    // @abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/insurance/contract.py:23
    // class AgriGuardInsurance(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/insurance/contract.py:43
    // @abimethod(create="require")
    callsub create_application
    intc_0 // 1
    return


// smart_contracts.insurance.contract.AgriGuardInsurance.create_application(admin: bytes) -> void:
create_application:
    // smart_contracts/insurance/contract.py:43-44
    // @abimethod(create="require")
    // def create_application(self, admin: Address) -> None:
    proto 1 0
    // smart_contracts/insurance/contract.py:46
    // self.admin = admin.native
    bytec 4 // "admin"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.set_oracle(oracle: bytes) -> void:
set_oracle:
    // smart_contracts/insurance/contract.py:48-49
    // @abimethod
    // def set_oracle(self, oracle: Address) -> None:
    proto 1 0
    // smart_contracts/insurance/contract.py:51
    // assert Txn.sender == self.admin, "Only admin can set oracle"
    txn Sender
    intc_1 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    ==
    assert // Only admin can set oracle
    // smart_contracts/insurance/contract.py:52
    // self.oracle = oracle.native
    bytec 5 // "oracle"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.buy_policy_with_payment(zip_code: bytes, t0: bytes, t1: bytes, cap: bytes, direction: bytes, threshold: bytes, slope: bytes, fee: bytes) -> bytes:
buy_policy_with_payment:
    // smart_contracts/insurance/contract.py:54-65
    // @abimethod
    // def buy_policy_with_payment(
    //     self,
    //     zip_code: DynamicBytes,
    //     t0: ARC4UInt64,
    //     t1: ARC4UInt64,
    //     cap: ARC4UInt64,
    //     direction: ARC4UInt64,
    //     threshold: ARC4UInt64,
    //     slope: ARC4UInt64,
    //     fee: ARC4UInt64
    // ) -> ARC4UInt64:
    proto 8 1
    // smart_contracts/insurance/contract.py:72-73
    // # Verify this is part of a group transaction
    // assert Global.group_size == UInt64(2), "Must be called in group transaction"
    global GroupSize
    intc_3 // 2
    ==
    assert // Must be called in group transaction
    // smart_contracts/insurance/contract.py:80-81
    // # Create policy
    // policy_id = self.next_policy_id
    intc_1 // 0
    bytec_1 // "next_policy_id"
    app_global_get_ex
    assert // check self.next_policy_id exists
    // smart_contracts/insurance/contract.py:82
    // self.next_policy_id += UInt64(1)
    dup
    intc_0 // 1
    +
    bytec_1 // "next_policy_id"
    swap
    app_global_put
    // smart_contracts/insurance/contract.py:85
    // owner=Address.from_bytes(Txn.sender.bytes),
    txn Sender
    // smart_contracts/insurance/contract.py:84-95
    // policy_data = PolicyData(
    //     owner=Address.from_bytes(Txn.sender.bytes),
    //     zip_code=ARC4String.from_bytes(zip_code.bytes),
    //     t0=t0,
    //     t1=t1,
    //     cap=cap,
    //     direction=direction,
    //     threshold=threshold,
    //     slope=slope,
    //     fee_paid=fee,
    //     settled=ARC4UInt64(0)
    // )
    bytec 7 // 0x0062
    concat
    frame_dig -7
    concat
    frame_dig -6
    concat
    frame_dig -5
    concat
    frame_dig -4
    concat
    frame_dig -3
    concat
    frame_dig -2
    concat
    frame_dig -1
    concat
    // smart_contracts/insurance/contract.py:94
    // settled=ARC4UInt64(0)
    bytec_2 // 0x0000000000000000
    // smart_contracts/insurance/contract.py:84-95
    // policy_data = PolicyData(
    //     owner=Address.from_bytes(Txn.sender.bytes),
    //     zip_code=ARC4String.from_bytes(zip_code.bytes),
    //     t0=t0,
    //     t1=t1,
    //     cap=cap,
    //     direction=direction,
    //     threshold=threshold,
    //     slope=slope,
    //     fee_paid=fee,
    //     settled=ARC4UInt64(0)
    // )
    concat
    frame_dig -8
    concat
    // smart_contracts/insurance/contract.py:97-98
    // # Store policy in box
    // self.policies[policy_id] = policy_data.copy()
    swap
    itob
    bytec_3 // "policies"
    dig 1
    concat
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/insurance/contract.py:100
    // return ARC4UInt64(policy_id)
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.buy_policy(zip_code: bytes, t0: bytes, t1: bytes, cap: bytes, direction: bytes, threshold: bytes, slope: bytes, fee: bytes) -> bytes:
buy_policy:
    // smart_contracts/insurance/contract.py:102-113
    // @abimethod
    // def buy_policy(
    //     self,
    //     zip_code: DynamicBytes,
    //     t0: ARC4UInt64,
    //     t1: ARC4UInt64,
    //     cap: ARC4UInt64,
    //     direction: ARC4UInt64,
    //     threshold: ARC4UInt64,
    //     slope: ARC4UInt64,
    //     fee: ARC4UInt64
    // ) -> ARC4UInt64:
    proto 8 1
    // smart_contracts/insurance/contract.py:118-119
    // # Create policy
    // policy_id = self.next_policy_id
    intc_1 // 0
    bytec_1 // "next_policy_id"
    app_global_get_ex
    assert // check self.next_policy_id exists
    // smart_contracts/insurance/contract.py:120
    // self.next_policy_id += UInt64(1)
    dup
    intc_0 // 1
    +
    bytec_1 // "next_policy_id"
    swap
    app_global_put
    // smart_contracts/insurance/contract.py:123
    // owner=Address.from_bytes(Txn.sender.bytes),
    txn Sender
    // smart_contracts/insurance/contract.py:122-133
    // policy_data = PolicyData(
    //     owner=Address.from_bytes(Txn.sender.bytes),
    //     zip_code=ARC4String.from_bytes(zip_code.bytes),
    //     t0=t0,
    //     t1=t1,
    //     cap=cap,
    //     direction=direction,
    //     threshold=threshold,
    //     slope=slope,
    //     fee_paid=fee,
    //     settled=ARC4UInt64(0)
    // )
    bytec 7 // 0x0062
    concat
    frame_dig -7
    concat
    frame_dig -6
    concat
    frame_dig -5
    concat
    frame_dig -4
    concat
    frame_dig -3
    concat
    frame_dig -2
    concat
    frame_dig -1
    concat
    // smart_contracts/insurance/contract.py:132
    // settled=ARC4UInt64(0)
    bytec_2 // 0x0000000000000000
    // smart_contracts/insurance/contract.py:122-133
    // policy_data = PolicyData(
    //     owner=Address.from_bytes(Txn.sender.bytes),
    //     zip_code=ARC4String.from_bytes(zip_code.bytes),
    //     t0=t0,
    //     t1=t1,
    //     cap=cap,
    //     direction=direction,
    //     threshold=threshold,
    //     slope=slope,
    //     fee_paid=fee,
    //     settled=ARC4UInt64(0)
    // )
    concat
    frame_dig -8
    concat
    // smart_contracts/insurance/contract.py:135-136
    // # Store policy in box
    // self.policies[policy_id] = policy_data.copy()
    swap
    itob
    bytec_3 // "policies"
    dig 1
    concat
    dup
    box_del
    pop
    uncover 2
    box_put
    // smart_contracts/insurance/contract.py:138
    // return ARC4UInt64(policy_id)
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.oracle_settle(policy_id: bytes, approved: bytes) -> bytes:
oracle_settle:
    // smart_contracts/insurance/contract.py:140-141
    // @abimethod
    // def oracle_settle(self, policy_id: ARC4UInt64, approved: ARC4UInt64) -> ARC4UInt64:
    proto 2 1
    // smart_contracts/insurance/contract.py:146-147
    // # Only oracle may settle
    // assert Txn.sender == self.oracle, "Only oracle"
    txn Sender
    intc_1 // 0
    bytec 5 // "oracle"
    app_global_get_ex
    assert // check self.oracle exists
    ==
    assert // Only oracle
    // smart_contracts/insurance/contract.py:149
    // pid = policy_id.native
    frame_dig -2
    btoi
    // smart_contracts/insurance/contract.py:150
    // policy_data = self.policies.maybe(pid)[0].copy()
    itob
    bytec_3 // "policies"
    swap
    concat
    dup
    box_get
    pop
    dup
    // smart_contracts/insurance/contract.py:152-153
    // # Check that policy is not already settled
    // assert policy_data.settled.native == UInt64(0), "Policy already settled"
    pushint 90 // 90
    extract_uint64
    !
    assert // Policy already settled
    // smart_contracts/insurance/contract.py:155
    // payout = UInt64(0)
    intc_1 // 0
    // smart_contracts/insurance/contract.py:156
    // if approved.native == UInt64(1):
    frame_dig -1
    btoi
    intc_0 // 1
    ==
    bz oracle_settle_after_if_else@2
    // smart_contracts/insurance/contract.py:157
    // payout = policy_data.cap.native
    frame_dig 1
    pushint 50 // 50
    extract_uint64
    frame_bury 2

oracle_settle_after_if_else@2:
    // smart_contracts/insurance/contract.py:159
    // if payout > UInt64(0):
    frame_dig 2
    bz oracle_settle_after_if_else@5
    // smart_contracts/insurance/contract.py:160-164
    // itxn.Payment(
    //     receiver=policy_data.owner.native,
    //     amount=payout,
    //     fee=UInt64(1000)
    // ).submit()
    itxn_begin
    // smart_contracts/insurance/contract.py:161
    // receiver=policy_data.owner.native,
    frame_dig 1
    extract 0 32 // on error: Index access is out of bounds
    frame_dig 2
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/insurance/contract.py:160
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/insurance/contract.py:163
    // fee=UInt64(1000)
    intc 4 // 1000
    itxn_field Fee
    // smart_contracts/insurance/contract.py:160-164
    // itxn.Payment(
    //     receiver=policy_data.owner.native,
    //     amount=payout,
    //     fee=UInt64(1000)
    // ).submit()
    itxn_submit

oracle_settle_after_if_else@5:
    // smart_contracts/insurance/contract.py:166-167
    // # Mark as settled
    // policy_data.settled = ARC4UInt64(1)
    frame_dig 1
    bytec 6 // 0x0000000000000001
    replace2 90
    // smart_contracts/insurance/contract.py:168
    // self.policies[pid] = policy_data.copy()
    frame_dig 0
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/insurance/contract.py:170
    // return ARC4UInt64(payout)
    frame_dig 2
    itob
    frame_bury 0
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.dispute_settlement(policy_id: bytes, reason: bytes) -> bytes:
dispute_settlement:
    // smart_contracts/insurance/contract.py:172-173
    // @abimethod
    // def dispute_settlement(self, policy_id: ARC4UInt64, reason: ARC4String) -> ARC4UInt64:
    proto 2 1
    // smart_contracts/insurance/contract.py:178
    // pid = policy_id.native
    frame_dig -2
    btoi
    // smart_contracts/insurance/contract.py:179
    // caller = Address.from_bytes(Txn.sender.bytes)
    txn Sender
    swap
    // smart_contracts/insurance/contract.py:181-182
    // # Check if policy exists and caller is owner
    // policy_data = self.policies.maybe(pid)[0].copy()
    itob
    bytec_3 // "policies"
    swap
    concat
    box_get
    // smart_contracts/insurance/contract.py:185
    // if not exists:
    bnz dispute_settlement_after_if_else@2
    // smart_contracts/insurance/contract.py:186
    // return ARC4UInt64(0)  # Policy doesn't exist
    bytec_2 // 0x0000000000000000
    frame_bury 0
    retsub

dispute_settlement_after_if_else@2:
    // smart_contracts/insurance/contract.py:188
    // if caller != policy_data.owner:
    frame_dig 1
    extract 0 32 // on error: Index access is out of bounds
    frame_dig 0
    !=
    bz dispute_settlement_after_if_else@4
    // smart_contracts/insurance/contract.py:189
    // return ARC4UInt64(0)  # Not the owner
    bytec_2 // 0x0000000000000000
    frame_bury 0
    retsub

dispute_settlement_after_if_else@4:
    // smart_contracts/insurance/contract.py:191-192
    // # Check if policy is already settled
    // if policy_data.settled.native == UInt64(0):
    frame_dig 1
    pushint 90 // 90
    extract_uint64
    bnz dispute_settlement_after_if_else@6
    // smart_contracts/insurance/contract.py:193
    // return ARC4UInt64(0)  # Policy not settled yet
    bytec_2 // 0x0000000000000000
    frame_bury 0
    retsub

dispute_settlement_after_if_else@6:
    // smart_contracts/insurance/contract.py:195-198
    // # Create dispute in dispute contract (if configured)
    // # This would call the dispute contract's create_dispute method
    // # For now, just mark that a dispute was requested
    // return ARC4UInt64(1)
    bytec 6 // 0x0000000000000001
    frame_bury 0
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.get_policy(policy_id: bytes) -> bytes:
get_policy:
    // smart_contracts/insurance/contract.py:200-201
    // @abimethod(readonly=True)
    // def get_policy(self, policy_id: ARC4UInt64) -> PolicyData:
    proto 1 1
    // smart_contracts/insurance/contract.py:203
    // return self.policies.maybe(policy_id.native)[0].copy()
    frame_dig -1
    btoi
    itob
    bytec_3 // "policies"
    swap
    concat
    box_get
    pop
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.get_policies_by_owner(owner: bytes) -> bytes:
get_policies_by_owner:
    // smart_contracts/insurance/contract.py:205-206
    // @abimethod(readonly=True)
    // def get_policies_by_owner(self, owner: Address) -> Tuple[ARC4UInt64, ARC4UInt64]:
    proto 1 1
    intc_1 // 0
    pushbytes ""
    dup
    // smart_contracts/insurance/contract.py:212
    // count = UInt64(0)
    intc_1 // 0
    // smart_contracts/insurance/contract.py:213
    // first_policy_id = UInt64(0)
    dupn 2
    // smart_contracts/insurance/contract.py:215-216
    // # Check each policy ID from 1 to next_policy_id - 1
    // for i in urange(1, self.next_policy_id):
    bytec_1 // "next_policy_id"
    app_global_get_ex
    assert // check self.next_policy_id exists
    intc_0 // 1

get_policies_by_owner_for_header@1:
    // smart_contracts/insurance/contract.py:215-216
    // # Check each policy ID from 1 to next_policy_id - 1
    // for i in urange(1, self.next_policy_id):
    frame_dig 6
    frame_dig 5
    <
    bz get_policies_by_owner_after_for@10
    // smart_contracts/insurance/contract.py:218
    // if self.policies.maybe(policy_id)[1]:  # Policy exists
    frame_dig 6
    itob
    bytec_3 // "policies"
    swap
    concat
    dup
    frame_bury 0
    box_get
    bury 1
    frame_dig 4
    frame_bury 2
    frame_dig 3
    frame_bury 1
    bz get_policies_by_owner_after_if_else@8
    // smart_contracts/insurance/contract.py:219
    // policy_data = self.policies.maybe(policy_id)[0].copy()
    frame_dig 0
    box_get
    pop
    // smart_contracts/insurance/contract.py:220
    // if policy_data.owner.native == owner.native:
    extract 0 32 // on error: Index access is out of bounds
    frame_dig -1
    ==
    frame_dig 4
    frame_bury 2
    frame_dig 3
    frame_bury 1
    bz get_policies_by_owner_after_if_else@7
    // smart_contracts/insurance/contract.py:221
    // count += UInt64(1)
    frame_dig 3
    intc_0 // 1
    +
    frame_bury 3
    frame_dig 4
    dup
    frame_bury 2
    // smart_contracts/insurance/contract.py:222
    // if first_policy_id == UInt64(0):
    bnz get_policies_by_owner_after_if_else@6
    frame_dig 6
    frame_bury 2

get_policies_by_owner_after_if_else@6:
    frame_dig 3
    frame_bury 1

get_policies_by_owner_after_if_else@7:
    b get_policies_by_owner_after_if_else@8

get_policies_by_owner_after_if_else@8:
    frame_dig 2
    frame_bury 4
    frame_dig 1
    frame_bury 3
    // smart_contracts/insurance/contract.py:215-216
    // # Check each policy ID from 1 to next_policy_id - 1
    // for i in urange(1, self.next_policy_id):
    frame_dig 6
    intc_0 // 1
    +
    frame_bury 6
    b get_policies_by_owner_for_header@1

get_policies_by_owner_after_for@10:
    // smart_contracts/insurance/contract.py:225
    // return Tuple((ARC4UInt64(count), ARC4UInt64(first_policy_id)))
    frame_dig 3
    itob
    frame_dig 4
    itob
    concat
    frame_bury 0
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.get_policy_count() -> bytes:
get_policy_count:
    // smart_contracts/insurance/contract.py:230
    // return ARC4UInt64(self.next_policy_id - UInt64(1))
    intc_1 // 0
    bytec_1 // "next_policy_id"
    app_global_get_ex
    assert // check self.next_policy_id exists
    intc_0 // 1
    -
    itob
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.calculate_fee(cap: bytes, risk_score: bytes, uncertainty: bytes, duration_days: bytes) -> bytes:
calculate_fee:
    // smart_contracts/insurance/contract.py:232-239
    // @abimethod(readonly=True)
    // def calculate_fee(
    //     self,
    //     cap: ARC4UInt64,
    //     risk_score: ARC4UInt64,
    //     uncertainty: ARC4UInt64,
    //     duration_days: ARC4UInt64
    // ) -> ARC4UInt64:
    proto 4 1
    // smart_contracts/insurance/contract.py:244-245
    // # Base fee: 1% of coverage amount
    // base_fee = cap.native // UInt64(100)
    frame_dig -4
    btoi
    intc_2 // 100
    /
    // smart_contracts/insurance/contract.py:247-248
    // # Risk multiplier: 1.0 to 2.0 based on risk score (0-100)
    // risk_multiplier = UInt64(100) + (risk_score.native // UInt64(2))  # 100-150 (1.0-1.5x)
    frame_dig -3
    btoi
    intc_3 // 2
    /
    intc_2 // 100
    +
    // smart_contracts/insurance/contract.py:250-251
    // # Uncertainty multiplier: 1.0 to 1.5 based on uncertainty (0-50%)
    // uncertainty_multiplier = UInt64(100) + uncertainty.native  # 100-150 (1.0-1.5x)
    frame_dig -2
    btoi
    intc_2 // 100
    +
    // smart_contracts/insurance/contract.py:253-254
    // # Duration multiplier: 1.0 to 2.0 based on duration (1-365 days)
    // duration_multiplier = UInt64(100) + (duration_days.native // UInt64(2))  # 100-282 (1.0-2.82x)
    frame_dig -1
    btoi
    intc_3 // 2
    /
    intc_2 // 100
    +
    // smart_contracts/insurance/contract.py:256-257
    // # Calculate final fee
    // fee = (base_fee * risk_multiplier * uncertainty_multiplier * duration_multiplier) // (UInt64(100) * UInt64(100) * UInt64(100))
    uncover 3
    uncover 3
    *
    uncover 2
    *
    *
    pushint 1000000 // 1000000
    /
    dup
    // smart_contracts/insurance/contract.py:259-260
    // # Minimum fee of 1000 microALGO
    // min_fee = UInt64(1000)
    intc 4 // 1000
    // smart_contracts/insurance/contract.py:261
    // if fee < min_fee:
    <
    bz calculate_fee_after_if_else@2
    // smart_contracts/insurance/contract.py:259-260
    // # Minimum fee of 1000 microALGO
    // min_fee = UInt64(1000)
    intc 4 // 1000
    // smart_contracts/insurance/contract.py:262
    // fee = min_fee
    frame_bury 0

calculate_fee_after_if_else@2:
    // smart_contracts/insurance/contract.py:264
    // return ARC4UInt64(fee)
    frame_dig 0
    itob
    swap
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.delete_policy(policy_id: bytes) -> bytes:
delete_policy:
    // smart_contracts/insurance/contract.py:266-267
    // @abimethod
    // def delete_policy(self, policy_id: ARC4UInt64) -> ARC4UInt64:
    proto 1 1
    // smart_contracts/insurance/contract.py:272
    // pid = policy_id.native
    frame_dig -1
    btoi
    // smart_contracts/insurance/contract.py:274-275
    // # Check if policy exists
    // policy_data = self.policies.maybe(pid)[0].copy()
    itob
    bytec_3 // "policies"
    swap
    concat
    dup
    box_get
    // smart_contracts/insurance/contract.py:278
    // if not exists:
    bnz delete_policy_after_if_else@2
    // smart_contracts/insurance/contract.py:279-280
    // # Policy doesn't exist
    // return ARC4UInt64(0)
    bytec_2 // 0x0000000000000000
    frame_bury 0
    retsub

delete_policy_after_if_else@2:
    // smart_contracts/insurance/contract.py:282-283
    // # Check if caller is the owner
    // caller = Address.from_bytes(Txn.sender.bytes)
    txn Sender
    // smart_contracts/insurance/contract.py:284
    // if caller != policy_data.owner:
    frame_dig 1
    extract 0 32 // on error: Index access is out of bounds
    !=
    bz delete_policy_after_if_else@4
    // smart_contracts/insurance/contract.py:285-286
    // # Caller is not the owner
    // return ARC4UInt64(0)
    bytec_2 // 0x0000000000000000
    frame_bury 0
    retsub

delete_policy_after_if_else@4:
    // smart_contracts/insurance/contract.py:288-289
    // # Check if policy is already settled
    // if policy_data.settled.native == UInt64(1):
    frame_dig 1
    pushint 90 // 90
    extract_uint64
    intc_0 // 1
    ==
    bz delete_policy_after_if_else@6
    // smart_contracts/insurance/contract.py:290-291
    // # Policy is already settled, cannot delete
    // return ARC4UInt64(0)
    bytec_2 // 0x0000000000000000
    frame_bury 0
    retsub

delete_policy_after_if_else@6:
    // smart_contracts/insurance/contract.py:293-295
    // # Delete the policy from storage
    // # In PyTeal BoxMap, we delete by using del keyword
    // del self.policies[pid]
    frame_dig 0
    box_del
    pop
    // smart_contracts/insurance/contract.py:297
    // return ARC4UInt64(1)
    bytec 6 // 0x0000000000000001
    frame_bury 0
    retsub


// smart_contracts.insurance.contract.AgriGuardInsurance.get_globals() -> bytes:
get_globals:
    // smart_contracts/insurance/contract.py:303
    // Address.from_bytes(self.admin.bytes),
    intc_1 // 0
    bytec 4 // "admin"
    app_global_get_ex
    assert // check self.admin exists
    // smart_contracts/insurance/contract.py:304
    // Address.from_bytes(self.oracle.bytes),
    intc_1 // 0
    bytec 5 // "oracle"
    app_global_get_ex
    assert // check self.oracle exists
    // smart_contracts/insurance/contract.py:305
    // ARC4UInt64(self.next_policy_id)
    intc_1 // 0
    bytec_1 // "next_policy_id"
    app_global_get_ex
    assert // check self.next_policy_id exists
    itob
    // smart_contracts/insurance/contract.py:302-306
    // return Tuple((
    //     Address.from_bytes(self.admin.bytes),
    //     Address.from_bytes(self.oracle.bytes),
    //     ARC4UInt64(self.next_policy_id)
    // ))
    cover 2
    concat
    swap
    concat
    retsub
